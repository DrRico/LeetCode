### **说说MySQL 事务**

MySQL 事务都是指在 **InnoDB 引擎**下，MyISAM 引擎是不支持事务的。

数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，什么都不做，其实不是没做，是可能做了一部分但是只要有一步失败，就要回滚所有操作，有点一不做二不休的意思。

事务具有：

- 原子性（Atomicity）、
- 一致性（Consistency）、
- 隔离性（Isolation）、
- 持久性（Durability）

> 事务的**原子性**是通过undo log来实现的，事务的**持久性**是通过redo log来实现的，事务的**隔离性**是通过(读写锁+MVCC)来实现的，而事务的终极大 boss**一致性**是通过原子性，持久性，隔离性来实现的！！！

四个特性，简称 **ACID**，缺一不可。今天要说的就是**隔离性**。

**脏读**

- 脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。

**可重复读**

- 可重复读指的是**在一个事务内**，**最开始读到的数据**和事务结束前的任意时刻读到的**同一批数据**都是**一致**的。通常针对数据**更新（UPDATE）**操作。

**不可重复读**

- 对比可重复读，不可重复读指的是**在同一事务内**，不同的时刻读到的同一批数据**可能是不一样的**，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。

**幻读**

- 幻读是针对数据**插入（INSERT）**操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

**事务隔离级别**

SQL 标准定义了四种隔离级别，Mysql 全都支持。这四种隔离级别分别是：

1. **读未提交（READ UNCOMMITTED）**
2. **读提交 （READ COMMITTED）**
3. **可重复读 （REPEATABLE READ）**
4. **串行化 （SERIALIZABLE）**

从上往下，隔离强度**逐渐增强**，性能**逐渐变差**。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是 MySQL 的默认级别。

**==事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题==**，下面展示了 4 种隔离级别对这三个问题的解决程度。

![img](https://pic3.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_1440w.jpg)

只有**串行化的隔离级别**解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。

**总结**

MySQL 的 InnoDB 引擎才支持事务，其中可重复读是默认的隔离级别。

读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。

读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。



































































































